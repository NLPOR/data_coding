"""
@author : 'XXY'
@contact : '529379497@qq.com'
@researchFie1d : 'NLP DL ML'
@date : 2018/9/25 0025 下午 9:21
"""
"""
概述：单例（Singleton）模式要求一个类有且仅有一个实例，并且提供了一个全局的访问点。
特点：
核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点

使用场景：
    1.需要生成唯一序列的环境
    2.需要频繁实例化后销毁的对象
    3.创建对象时耗时过多或者消耗资源过多，但又经常用到的对象
    4.方便资源相互通信的环境

优点：
    1.实现了对唯一实例访问的可控
    2.对于一些需要频繁创建和销毁的对象来说可以提高系统的性能

缺点：
    1、不适于频繁变化的对象
    2、滥用单例将会带来一些负面影响,如为了节省资源将数据库连接池对象设计为的单例类，
       可能会导致共享连接池对象的程序过多而出现连接池溢出。
    3.如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失。
+
举个栗子：
1.在windows桌面上，我们打开了一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的
回收站窗口，也就是说在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。继续说回
收站，我们在实际使用中并不存在需要同时打开两个回收站窗口的必要性。假如我每次创建回收站时都需要消耗大量的资源，
而每个回收站之间资源是共享的，那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不
必要的负担，造成资源浪费。

2.再举一个例子，网站的计数器，一般也是采用单例模式实现，如果你存在多个计数器，每一个用户的访问都刷新计数器的值，
这样的话你的实计数的值是难以同步的。但是如果采用单例模式实现就不会存在这样的问题，而且还可以避免线程安全问题。
同样多线程的线程池的设计一般也是采用单例模式，这是由于线程池需要方便对池中的线程进行控制同样，对于一些应用程序
的日志应用，或者web开发中读取配置文件都适合使用单例模式，如HttpApplication 就是单例的典型应用。
"""


# 普通模式
class A(object):
    def __init__(self, name, male):
        self.name = name
        self.male = male


# 单例模式
class B(object):
    __instance = None

    def __init__(self, name, male):
        self.name = name
        self.name = male

    @staticmethod

    def create_obj():
        if not B.__instance:
            B.__instance = A('ben','boy')
            return B.__instance
        else:
            return B.__instance






if __name__ == '__main__':
    # obj1 = A('ben', 'boy')
    # obj2 = A('min', 'girl')
    # obj3 = A('miao', 'boy')
    # print(id(obj1), id(obj2), id(obj3))

    x1 = B('ben', 'boy')
    x2 = B('ben', 'boy')
    x3 = B('ben', 'boy')
    print(id(x1), id(x2), id(x3))